{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pycocowriter","text":"<p>This library contains tools to assist in writing COCO-format annotation files. Contains typing and constructors to assist in building a COCO-format file from scratch and then dump it to json. Contains helpful conversion tools to assist in converting annotations in flat files or from SQL queries into COCO format.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pycocowriter\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We would love to have your contributions that improve current functionality, fix bugs, or add new features that facilitate parsing generic image annotation formats into COCO format.  See the contributing guidelines for more info.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This repository is a scientific product and is not official communication of the National Oceanic and Atmospheric Administration, or the United States Department of Commerce. All NOAA GitHub project code is provided on an \u2018as is\u2019 basis and the user assumes responsibility for its use. Any claims against the Department of Commerce or Department of Commerce bureaus stemming from the use of this GitHub project will be governed by all applicable Federal law. Any reference to specific commercial products, processes, or services by service mark, trademark, manufacturer, or otherwise, does not constitute or imply their endorsement, recommendation or favoring by the Department of Commerce. The Department of Commerce seal and logo, or the seal and logo of a DOC bureau, shall not be used in any manner to imply endorsement of any commercial product or activity by DOC or the United States Government.</p>"},{"location":"api/coco/","title":"COCO module","text":""},{"location":"api/coco/#pycocowriter.coco.COCOAnnotation","title":"<code>COCOAnnotation</code>","text":"<p>               Bases: <code>COCOBase</code></p> <p>see https://cocodataset.org/#format-data</p> <p>see https://github.com/cocodataset/cocoapi/issues/184</p> <pre><code>annotation {\n    \"id\": int,\n    \"image_id\": int,\n    \"category_id\": int,\n    \"segmentation\": RLE or [polygon],\n    \"area\": float,\n    \"bbox\": [x,y,width,height],\n    \"iscrowd\": 0 or 1,\n    \"keypoints\": [x1,y1,v1...],\n    \"num_keypoints\": int\n}\n</code></pre> <p>keypoints should be 3*len(keypoints_category), where keypoints_category is the keypoints in the corresponding category</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOAnnotation(COCOBase):\n    '''\n        see https://cocodataset.org/#format-data\n\n        see https://github.com/cocodataset/cocoapi/issues/184\n\n            annotation {\n                \"id\": int,\n                \"image_id\": int,\n                \"category_id\": int,\n                \"segmentation\": RLE or [polygon],\n                \"area\": float,\n                \"bbox\": [x,y,width,height],\n                \"iscrowd\": 0 or 1,\n                \"keypoints\": [x1,y1,v1...],\n                \"num_keypoints\": int\n            }\n\n        keypoints should be 3*len(keypoints_category), where keypoints_category is the keypoints in the corresponding category\n    '''\n    def __init__(self, image_id:int, eye_d:int, category_id:int, bbox:tuple[int]=None, area:float=None, segmentation=None, iscrowd:int=None, keypoints:list[int]=None):\n        self.image_id = image_id\n        self.id = eye_d\n        self.category_id = category_id\n        self.bbox = bbox\n        area = area or self._compute_area()\n        self.area = area\n        self.segmentation = segmentation\n        self.iscrowd = iscrowd or 0\n        self.keypoints = keypoints\n        self.num_keypoints = self._compute_num_keypoints()\n\n    def _compute_num_keypoints(self):\n        if self.keypoints is not None:\n            # the number of keypoints is the number of \"visible\" keypoints.\n            return sum([v &gt; 0 for v in self.keypoints[::3]])\n        return None\n\n    def _compute_area(self):\n        if self.bbox is not None:\n            return self.bbox[-1] * self.bbox[-2]\n        return None\n\n    def to_dict(self):\n        return self._to_dict_fields(\n            ['image_id', 'id', 'category_id', 'bbox', \n             'area', 'segmentation', 'iscrowd', \n             'keypoints', 'num_keypoints'])\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOBase","title":"<code>COCOBase</code>","text":"<p>               Bases: <code>object</code></p> <p>base class to facilitate conversion of COCO stuff to a dictionary.</p> <p>TODO: refactor COCO classes to extend pycocotools' COCO</p> <p>TODO: refactor COCO classes to use AttrDict</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOBase(object):\n    '''\n    base class to facilitate conversion of COCO stuff to a dictionary.\n\n    TODO: refactor COCO classes to extend pycocotools' COCO\n\n    TODO: refactor COCO classes to use AttrDict\n    '''\n    def _to_dict_fields(self, fields:list[str]) -&gt; dict:\n        return {field: self.__dict__[field] for field in fields if self.__dict__[field] is not None}\n    def to_dict(self):\n        '''convert COCO object to dictionary'''\n        raise NotImplementedError('must implement a to_dict method!')\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOBase.to_dict","title":"<code>to_dict()</code>","text":"<p>convert COCO object to dictionary</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>def to_dict(self):\n    '''convert COCO object to dictionary'''\n    raise NotImplementedError('must implement a to_dict method!')\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOCategories","title":"<code>COCOCategories</code>","text":"<p>               Bases: <code>object</code></p> <p>helper class to hold the index on categories so that we can find categories by name or by index</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>list[COCOCategory] | None</code> <p>existing list of COCOCategories if available</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>categories</code> <code>list[COCOCategory]</code> <p>a list of unique categories</p> <code>category_map</code> <code>dict[str, COCOCategory]</code> <p>maps category names to categories</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOCategories(object):\n    '''\n    helper class to hold the index on categories so that we can find categories by name or by index\n\n    Parameters\n    ----------\n    categories: list[COCOCategory]\n        existing list of COCOCategories if available\n\n    Attributes\n    ----------\n    categories: list[COCOCategory]\n        a list of unique categories\n    category_map: dict[str, COCOCategory]\n        maps category names to categories\n    '''\n    def __init__(self, categories: list[COCOCategory] | None = None):\n        categories = categories or []\n        # category ids MUST match their index in the category list!\n        self.categories = categories\n        for i, category in enumerate(self.categories):\n            assert category.id == i\n        self.category_map = {category.name: category.id for category in self.categories}\n\n    def add(self, label:str, keypoints:list[str]=None, skeleton:list[list[int]]=None) -&gt; COCOCategory:\n        '''\n        Add a new category to the list.  Updates the map as well\n\n        Parameters\n        ----------\n        label: str\n            the string name of this category\n        keypoints: list[str]\n            the list of keypoint names for this category, if applicable\n        skeleton: list[list[int]]\n            the skeleton for this category, if applicable\n\n        Returns\n        -------\n        category: COCOCategory\n            returns the built COCOCategory\n        '''\n        if label not in self.category_map:\n            category = COCOCategory(label, len(self.categories), keypoints=keypoints, skeleton=skeleton)\n            self.categories.append(category)\n            self.category_map[self.categories[-1].name] = self.categories[-1].id\n        return self.category_map[label]\n\n    def __len__(self):\n        return len(self.categories)\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOCategories.add","title":"<code>add(label, keypoints=None, skeleton=None)</code>","text":"<p>Add a new category to the list.  Updates the map as well</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>the string name of this category</p> required <code>keypoints</code> <code>list[str]</code> <p>the list of keypoint names for this category, if applicable</p> <code>None</code> <code>skeleton</code> <code>list[list[int]]</code> <p>the skeleton for this category, if applicable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>category</code> <code>COCOCategory</code> <p>returns the built COCOCategory</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>def add(self, label:str, keypoints:list[str]=None, skeleton:list[list[int]]=None) -&gt; COCOCategory:\n    '''\n    Add a new category to the list.  Updates the map as well\n\n    Parameters\n    ----------\n    label: str\n        the string name of this category\n    keypoints: list[str]\n        the list of keypoint names for this category, if applicable\n    skeleton: list[list[int]]\n        the skeleton for this category, if applicable\n\n    Returns\n    -------\n    category: COCOCategory\n        returns the built COCOCategory\n    '''\n    if label not in self.category_map:\n        category = COCOCategory(label, len(self.categories), keypoints=keypoints, skeleton=skeleton)\n        self.categories.append(category)\n        self.category_map[self.categories[-1].name] = self.categories[-1].id\n    return self.category_map[label]\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOCategory","title":"<code>COCOCategory</code>","text":"<p>               Bases: <code>COCOBase</code></p> <p>see https://cocodataset.org/#format-data</p> <p>see https://github.com/facebookresearch/Detectron/issues/640</p> <pre><code>category {\n    \"id\": int,\n    \"name\": str,\n    \"supercategory\": str,\n    \"keypoints\": [str],\n    \"skeleton\": [edge]\n}\n</code></pre> <p>An edge is a tuple [a,b] where a,b are 1-indexed indices in the keypoints list.  So if keypoints is [\"a\", \"b\"], then [1,2] is an edge between \"a\" and \"b\"</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOCategory(COCOBase):\n    '''\n        see https://cocodataset.org/#format-data\n\n        see https://github.com/facebookresearch/Detectron/issues/640\n\n            category {\n                \"id\": int,\n                \"name\": str,\n                \"supercategory\": str,\n                \"keypoints\": [str],\n                \"skeleton\": [edge]\n            }\n\n        An edge is a tuple [a,b] where a,b are 1-indexed indices in the keypoints list.  So if keypoints is [\"a\", \"b\"], then [1,2] is an edge between \"a\" and \"b\"\n    '''\n    def __init__(self, name:str, eye_d:int, supercategory:str=None, keypoints:list[str]=None, skeleton:list[list[int]]=None):\n        self.name = name\n        self.id = eye_d\n        self.supercategory = supercategory\n        self.keypoints = keypoints\n        self.skeleton = skeleton\n\n    def to_dict(self):\n        return self._to_dict_fields(\n            ['name', 'id', 'supercategory', 'keypoints', 'skeleton']\n        )\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOData","title":"<code>COCOData</code>","text":"<p>               Bases: <code>COCOBase</code></p> <p>see https://cocodataset.org/#format-data</p> <pre><code>coco {\n    \"info\": info,\n    \"images\": [image],\n    \"annotations\": [annotation],\n    \"licenses\": [license],\n    \"categories\": [category]\n}\n</code></pre> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOData(COCOBase):\n    '''\n        see https://cocodataset.org/#format-data\n\n            coco {\n                \"info\": info,\n                \"images\": [image],\n                \"annotations\": [annotation],\n                \"licenses\": [license],\n                \"categories\": [category]\n            }\n    '''\n\n    def __init__(self, info:COCOInfo, images:list[COCOImage], annotations:list[COCOAnnotation], licenses:list[COCOLicense], categories:list[COCOCategory]):\n        self.info = info\n        self.images = images\n        self.annotations = annotations\n        self.licenses = licenses\n        self.categories = categories\n\n    def to_dict(self) -&gt; dict:\n        return {\n            'info': self.info.to_dict(),\n            'images': [image.to_dict() for image in self.images],\n            'annotations': [annotation.to_dict() for annotation in self.annotations],\n            'licenses': [license.to_dict() for license in self.licenses],\n            'categories': [category.to_dict() for category in self.categories]\n        }\n\n    def to_json(self, filename:str=None):\n        '''\n        dumps this COCO to json.  If a filename is provided, writes to disk, else, returns\n        the string JSON\n\n        Parameters\n        ----------\n        filename: str\n            the optional location to which we should write the json\n\n        Returns\n        -------\n        json: str | None\n            if no filename is provided, returns the JSON COCO data as a string\n        '''\n        if filename is None:\n            return json.dumps(self.to_dict(), cls=utils.NPEncoder)\n        with open(filename, 'w') as f:\n            json.dump(self.to_dict(), f, cls=utils.NPEncoder)\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOData.to_json","title":"<code>to_json(filename=None)</code>","text":"<p>dumps this COCO to json.  If a filename is provided, writes to disk, else, returns the string JSON</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the optional location to which we should write the json</p> <code>None</code> <p>Returns:</p> Name Type Description <code>json</code> <code>str | None</code> <p>if no filename is provided, returns the JSON COCO data as a string</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>def to_json(self, filename:str=None):\n    '''\n    dumps this COCO to json.  If a filename is provided, writes to disk, else, returns\n    the string JSON\n\n    Parameters\n    ----------\n    filename: str\n        the optional location to which we should write the json\n\n    Returns\n    -------\n    json: str | None\n        if no filename is provided, returns the JSON COCO data as a string\n    '''\n    if filename is None:\n        return json.dumps(self.to_dict(), cls=utils.NPEncoder)\n    with open(filename, 'w') as f:\n        json.dump(self.to_dict(), f, cls=utils.NPEncoder)\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOImage","title":"<code>COCOImage</code>","text":"<p>               Bases: <code>COCOBase</code></p> <p>see https://cocodataset.org/#format-data</p> <pre><code>image {\n    \"id\": int,\n    \"width\": int,\n    \"height\": int,\n    \"file_name\": str,\n    \"license\": int,\n    \"flickr_url\": str,\n    \"coco_url\": str,\n    \"date_captured\": datetime,\n}\n</code></pre> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOImage(COCOBase):\n    '''\n        see https://cocodataset.org/#format-data\n\n            image {\n                \"id\": int,\n                \"width\": int,\n                \"height\": int,\n                \"file_name\": str,\n                \"license\": int,\n                \"flickr_url\": str,\n                \"coco_url\": str,\n                \"date_captured\": datetime,\n            }\n    '''\n    def __init__(self, \n                 eye_d:int, file_name:str, \n                 width:int=None, height:int=None, \n                 license:int=None, coco_url:str=None, \n                 date_captured:datetime.datetime=None):\n        self.id = eye_d\n        self.file_name = file_name\n        self.width = width\n        self.height = height\n        self.license = license\n        self.coco_url = coco_url\n        self.date_captured = date_captured\n\n    def to_dict(self) -&gt; dict:\n        the_dict = self._to_dict_fields(\n            ['id', 'file_name', 'width', 'height', 'license', 'coco_url']\n        )\n        if self.date_captured:\n            the_dict['date_captured'] = self.date_captured.isoformat()\n        return the_dict\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOImages","title":"<code>COCOImages</code>","text":"<p>               Bases: <code>object</code></p> <p>helper class to hold the index on images so that we can find images by name or by index</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list[COCOImage] | None</code> <p>existing list of COCOImages if available</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>images</code> <code>list[COCOImage]</code> <p>a list of unique images</p> <code>image_map</code> <code>dict[str, COCOImage]</code> <p>maps image names to images</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOImages(object):\n    '''\n    helper class to hold the index on images so that we can find images by name or by index\n\n    Parameters\n    ----------\n    images: list[COCOImage]\n        existing list of COCOImages if available\n\n    Attributes\n    ----------\n    images: list[COCOImage]\n        a list of unique images\n    image_map: dict[str, COCOImage]\n        maps image names to images\n    '''\n    def __init__(self, images: list[COCOImage] | None = None):\n        images = images or []\n        # image ids MUST match their index in the image list!\n        self.images = images\n        for i, image in enumerate(self.images):\n            assert image.id == i\n        self.image_map = {image.filename: image.id for image in self.images}\n\n    def add(self, filename:str, width:int=None, height:int=None, \n            url:str=None, license:int=None, date_captured:datetime.datetime=None):\n        '''\n        Add a new image to the list.  Updates the map as well\n\n        Parameters\n        ----------\n        filename: str\n            the filename of this image\n        width: int\n            the width of this image, if known\n        height: int\n            the height of this image, if known\n        url: str\n            the url at which this image can be downloaded\n        license: int\n            the index in the list of COCOLicense with the applicable license\n        date_captured: datetime.datetime\n            the date and time when the image was captured\n\n        Returns\n        -------\n        image: COCOImage\n            returns the built COCOImage\n        '''\n        if filename not in self.image_map:\n            image = COCOImage(len(self.images), filename, \n                              width=width, height=height, coco_url=url, \n                              license=license, date_captured=date_captured)\n            self.images.append(image)\n            self.image_map[self.images[-1].file_name] = self.images[-1].id\n        return self.image_map[filename]\n\n    def __len__(self):\n        return len(self.images)\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOImages.add","title":"<code>add(filename, width=None, height=None, url=None, license=None, date_captured=None)</code>","text":"<p>Add a new image to the list.  Updates the map as well</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename of this image</p> required <code>width</code> <code>int</code> <p>the width of this image, if known</p> <code>None</code> <code>height</code> <code>int</code> <p>the height of this image, if known</p> <code>None</code> <code>url</code> <code>str</code> <p>the url at which this image can be downloaded</p> <code>None</code> <code>license</code> <code>int</code> <p>the index in the list of COCOLicense with the applicable license</p> <code>None</code> <code>date_captured</code> <code>datetime</code> <p>the date and time when the image was captured</p> <code>None</code> <p>Returns:</p> Name Type Description <code>image</code> <code>COCOImage</code> <p>returns the built COCOImage</p> Source code in <code>pycocowriter/coco.py</code> <pre><code>def add(self, filename:str, width:int=None, height:int=None, \n        url:str=None, license:int=None, date_captured:datetime.datetime=None):\n    '''\n    Add a new image to the list.  Updates the map as well\n\n    Parameters\n    ----------\n    filename: str\n        the filename of this image\n    width: int\n        the width of this image, if known\n    height: int\n        the height of this image, if known\n    url: str\n        the url at which this image can be downloaded\n    license: int\n        the index in the list of COCOLicense with the applicable license\n    date_captured: datetime.datetime\n        the date and time when the image was captured\n\n    Returns\n    -------\n    image: COCOImage\n        returns the built COCOImage\n    '''\n    if filename not in self.image_map:\n        image = COCOImage(len(self.images), filename, \n                          width=width, height=height, coco_url=url, \n                          license=license, date_captured=date_captured)\n        self.images.append(image)\n        self.image_map[self.images[-1].file_name] = self.images[-1].id\n    return self.image_map[filename]\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOInfo","title":"<code>COCOInfo</code>","text":"<p>               Bases: <code>COCOBase</code></p> <p>see https://cocodataset.org/#format-data</p> <pre><code>info {\n    \"year\": int,\n    \"version\": str,\n    \"description\": str,\n    \"contributor\": str,\n    \"url\": str,\n    \"date_created\": datetime,\n}\n</code></pre> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOInfo(COCOBase):\n    '''\n        see https://cocodataset.org/#format-data\n\n            info {\n                \"year\": int,\n                \"version\": str,\n                \"description\": str,\n                \"contributor\": str,\n                \"url\": str,\n                \"date_created\": datetime,\n            }\n    '''\n    def __init__(self, year:int=None, version:str=None, description:str=None, contributor:str=None, url:str=None, date_created:datetime.datetime=None):\n        self.year = year\n        self.version = version\n        self.description = description\n        self.contributor = contributor\n        self.url = url\n        self.date_created = date_created\n\n    def to_dict(self) -&gt; dict:\n        the_dict = self._to_dict_fields(\n            ['year', 'version', 'description', 'contributor', 'url']\n        )\n        if self.date_created:\n            the_dict['date_created'] = self.date_created.isoformat()\n        return the_dict\n</code></pre>"},{"location":"api/coco/#pycocowriter.coco.COCOLicense","title":"<code>COCOLicense</code>","text":"<p>               Bases: <code>COCOBase</code></p> <p>see https://cocodataset.org/#format-data</p> <pre><code>license {\n    \"id\": int,\n    \"name\": str,\n    \"url\": str,\n}\n</code></pre> Source code in <code>pycocowriter/coco.py</code> <pre><code>class COCOLicense(COCOBase):\n    '''\n        see https://cocodataset.org/#format-data\n\n            license {\n                \"id\": int,\n                \"name\": str,\n                \"url\": str,\n            }\n    '''\n    def __init__(self, name:str, eye_d:int, url:str=None):\n        self.name = name\n        self.id = eye_d\n        self.url = url\n\n    def to_dict(self):\n        return self._to_dict_fields(\n            ['name', 'id', 'url']\n        )\n</code></pre>"},{"location":"api/csv2coco/","title":"CSV2COCO module","text":""},{"location":"api/csv2coco/#pycocowriter.csv2coco.Iterable2COCO","title":"<code>Iterable2COCO</code>","text":"<p>               Bases: <code>object</code></p> <p>class providing methods for parsing a \"flat\" iterable (e.g. a csv) of annotations into COCO format.  Each \"row\" should contain things such as the image filename,  and the annotation information (e.g a bounding box or keypoints and a category label)</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Iterable2COCOConfig</code> <p>a configuration dictionary detailing which columns in each row correspond to various COCO features such as filename and bounding box coordinates.</p> required <p>Attributes:</p> Name Type Description <code>bbox_parser</code> <code>IterableBBoxParser</code> <p>a helper for parsing bounding boxes and the concomitant configuration</p> <code>keypoint_parser</code> <code>IterableKeypointParser</code> <p>a helper for parsing keypoints and the concomitant configuration</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>class Iterable2COCO(object):\n    '''\n    class providing methods for parsing a \"flat\" iterable (e.g. a csv) of annotations into COCO\n    format.  Each \"row\" should contain things such as the image filename, \n    and the annotation information (e.g a bounding box or keypoints and a category label)\n\n    Parameters\n    ----------\n    config: Iterable2COCOConfig\n        a configuration dictionary detailing which columns in each row correspond to various COCO\n        features such as filename and bounding box coordinates.\n\n    Attributes\n    ----------\n    bbox_parser: IterableBBoxParser\n        a helper for parsing bounding boxes and the concomitant configuration\n    keypoint_parser: IterableKeypointParser\n        a helper for parsing keypoints and the concomitant configuration\n    '''\n\n    def __init__(self, config: Iterable2COCOConfig):\n        self.config = config\n        self.bbox_parser = IterableBBoxParser(config)\n        self.keypoint_parser = IterableKeypointParser(config)\n\n    def _get_scalar(self, field: str, row: Sequence):\n        '''\n        get a single value from a row given the field name in the configuration\n\n        Parameters\n        ----------\n        field: str\n            the field name as expected in the configuration, and should point to a column index.\n            viz. self.config[field] should provide an index into row\n        row: Sequence\n            an indexable \"row\" e.g. from a csv file\n\n        Returns\n        -------\n        scalar: any\n           a single value expected for that field. \n        '''\n        if field not in self.config:\n            return None\n        return row[self.config[field]]\n\n    def parse(self, row_iterable: Iterable[Sequence]) -&gt; tuple[\n        list[coco.COCOImage], list[coco.COCOAnnotation], list[coco.COCOCategory]\n    ]:\n        '''\n        parse an iterable of rows (e.g. from a csv file) containing image annotation information into\n        COCO format.\n\n        Parameters\n        ----------\n        row_iterable: Iterable[Sequence]\n            an iterable of rows containing annotation information\n\n        Returns\n        -------\n        images: list[COCOImage]\n            a list of all unique images listed in the iterable, in COCO format\n        annotations: list[COCOAnnotation]\n            a list of all annotations listed in the iterable, correctly indexed\n            against the images and categories lists\n        categories: list[COCOCategory]\n            a list of all unique categories listed in the iterable, in COCO format        \n        '''\n        categories = coco.COCOCategories()\n        images = coco.COCOImages()\n        annotations = []\n        utils.skiprows(row_iterable, self.config.meta.skiprows)\n        keypoint_names, keypoint_skeleton = self.keypoint_parser.keypoint_config()\n        for row in row_iterable:\n            bbox = self.bbox_parser.get_bbox(row)\n            keypoints = self.keypoint_parser.get_keypoints(row)\n            filename = self._get_scalar('filename', row)\n            width = self._get_scalar('width', row)\n            height = self._get_scalar('height', row)\n            label = self._get_scalar('label', row)\n            images.add(filename, width, height)\n            categories.add(label, keypoint_names, keypoint_skeleton)\n            annotations.append(\n                coco.COCOAnnotation(\n                    images.image_map[filename],\n                    len(annotations),\n                    categories.category_map[label],\n                    bbox=bbox,\n                    keypoints=keypoints\n                )\n            )\n        return images.images, annotations, categories.categories\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.Iterable2COCO.parse","title":"<code>parse(row_iterable)</code>","text":"<p>parse an iterable of rows (e.g. from a csv file) containing image annotation information into COCO format.</p> <p>Parameters:</p> Name Type Description Default <code>row_iterable</code> <code>Iterable[Sequence]</code> <p>an iterable of rows containing annotation information</p> required <p>Returns:</p> Name Type Description <code>images</code> <code>list[COCOImage]</code> <p>a list of all unique images listed in the iterable, in COCO format</p> <code>annotations</code> <code>list[COCOAnnotation]</code> <p>a list of all annotations listed in the iterable, correctly indexed against the images and categories lists</p> <code>categories</code> <code>list[COCOCategory]</code> <p>a list of all unique categories listed in the iterable, in COCO format</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>def parse(self, row_iterable: Iterable[Sequence]) -&gt; tuple[\n    list[coco.COCOImage], list[coco.COCOAnnotation], list[coco.COCOCategory]\n]:\n    '''\n    parse an iterable of rows (e.g. from a csv file) containing image annotation information into\n    COCO format.\n\n    Parameters\n    ----------\n    row_iterable: Iterable[Sequence]\n        an iterable of rows containing annotation information\n\n    Returns\n    -------\n    images: list[COCOImage]\n        a list of all unique images listed in the iterable, in COCO format\n    annotations: list[COCOAnnotation]\n        a list of all annotations listed in the iterable, correctly indexed\n        against the images and categories lists\n    categories: list[COCOCategory]\n        a list of all unique categories listed in the iterable, in COCO format        \n    '''\n    categories = coco.COCOCategories()\n    images = coco.COCOImages()\n    annotations = []\n    utils.skiprows(row_iterable, self.config.meta.skiprows)\n    keypoint_names, keypoint_skeleton = self.keypoint_parser.keypoint_config()\n    for row in row_iterable:\n        bbox = self.bbox_parser.get_bbox(row)\n        keypoints = self.keypoint_parser.get_keypoints(row)\n        filename = self._get_scalar('filename', row)\n        width = self._get_scalar('width', row)\n        height = self._get_scalar('height', row)\n        label = self._get_scalar('label', row)\n        images.add(filename, width, height)\n        categories.add(label, keypoint_names, keypoint_skeleton)\n        annotations.append(\n            coco.COCOAnnotation(\n                images.image_map[filename],\n                len(annotations),\n                categories.category_map[label],\n                bbox=bbox,\n                keypoints=keypoints\n            )\n        )\n    return images.images, annotations, categories.categories\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.Iterable2COCOConfig","title":"<code>Iterable2COCOConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>This class validates a configuration to convert a \"flat\" iterable type into COCO. Because COCO has complex nested and optional types, it is not possible to have a  \"one-size-fits-all\" flat iterable to COCO conversion.  This configuration tells the converter which fields are present, and in which columns they are located. This class exists only to validate a dict as a valid configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>a configuration dictionary adhering to SCHEMA.  Set up this way to be read from .json</p> required <p>Attributes:</p> Name Type Description <code>SCHEMA</code> <code>dict</code> <p>a jsonschema representing a valid configuration</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>class Iterable2COCOConfig(utils.AttrDict):\n    '''\n    This class validates a configuration to convert a \"flat\" iterable type into COCO.\n    Because COCO has complex nested and optional types, it is not possible to have a \n    \"one-size-fits-all\" flat iterable to COCO conversion.  This configuration tells\n    the converter which fields are present, and in which columns they are located.\n    This class exists only to validate a dict as a valid configuration.\n\n    Parameters\n    ----------\n    config: dict\n        a configuration dictionary adhering to SCHEMA.  Set up this way to be read from .json\n\n    Attributes\n    ----------\n    SCHEMA: dict\n        a jsonschema representing a valid configuration\n    '''\n\n    # TODO: This is the 'anything' schema.  Update to reflect the actual rules\n    SCHEMA = {}\n\n    def __init__(self, config: dict):\n        self._validate_config(config)\n        super().__init__(config)\n\n    def _validate_config(self, config: dict):\n        jsonschema.validate(config, Iterable2COCOConfig.SCHEMA)\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.IterableBBoxParser","title":"<code>IterableBBoxParser</code>","text":"<p>               Bases: <code>object</code></p> <p>This class is to help parse bounding boxes from \"row\" data.  Sometimes these data are in different formats, so this class is intended to assist in dealing with these nuances</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Iterable2COCOConfig</code> <p>this configuration should define how (and if) bounding boxes are present in each row</p> required Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>class IterableBBoxParser(object):\n    '''\n    This class is to help parse bounding boxes from \"row\" data.  Sometimes these data\n    are in different formats, so this class is intended to assist in dealing with these nuances\n\n    Parameters\n    ----------\n    config: Iterable2COCOConfig\n        this configuration should define how (and if) bounding boxes are present in each row\n    '''\n\n    def __init__(self, config: Iterable2COCOConfig):\n        self.config = config\n        self._init_bbox_method()\n\n    def _init_bbox_tlbr(self):\n        '''\n        configures the `get_bbox` method to get bounding boxes in \"top left, width/height\" \n        format, given bounding boxes in \"top left, bottom right\" format\n        '''\n        self.get_bbox = self._get_bbox_tlbr\n        self.bbox_cols = [\n            self.config.bbox_tlbr.tlx,\n            self.config.bbox_tlbr.tly,\n            self.config.bbox_tlbr.brx,\n            self.config.bbox_tlbr.bry,\n        ]\n\n    def _init_bbox_xywh(self):\n        '''\n        configures the `get_bbox` method to get bounding boxes in \"top left, width/height\" \n        format, given bounding boxes in \"top left, width/height\" format\n        '''\n        self.get_bbox = self._get_bbox_xywh\n        self.bbox_cols = [\n            self.config.bbox_xywh.x,\n            self.config.bbox_xywh.y,\n            self.config.bbox_xywh.w,\n            self.config.bbox_xywh.h,\n        ]\n\n    def _init_bbox_method(self):\n        '''\n        dispatches configuration of the `get_bbox` method depending on the \n        contents of the configuration file.\n        '''\n        if 'bbox_tlbr' in self.config:\n            self._init_bbox_tlbr()\n        elif 'bbox_xywh' in self.config:\n            self._init_bbox_xywh()\n\n    def get_bbox(self, row: Sequence) -&gt; list[int, int, int, int] | None:\n        '''\n        this method gets overwritten in __init__ if the config has a bbox option\n\n        Parameters\n        ----------\n        row: Sequence\n            a row, e.g. from a csv.  The bounding box should be in some columns of this row\n            as defined in the configuration\n\n        Returns\n        -------\n        bbox: list[int,int,int,int]\n            the bounding box as [top_left_x, top_left_y, width, height]\n        '''\n        return None\n\n    def _get_bbox_tlbr(self, row: Sequence) -&gt; list[int, int, int, int]:\n        '''\n        gets a bounding box in \"top left, width/height\" format given bounding box subsetted from a  \n        row from, e.g. a csv.  The subset of columns in the input row should be defined in the config, \n        and should contain a bounding box in \"top left, bottom right\" format.\n\n        Parameters\n        ----------\n        row: Sequence\n            a row, e.g. from a csv.  The bounding box should be in some columns of this row\n            as defined in the configuration\n\n        Returns\n        -------\n        bbox: list[int,int,int,int]\n            the bounding box as [top_left_x, top_left_y, width, height]\n        '''\n        return bbox_tlbr2xywh([int(float(row[i])) for i in self.bbox_cols])\n\n    def _get_bbox_xywh(self, row: Sequence) -&gt; list[int, int, int, int]:\n        '''\n        gets a bounding box in \"top left, width/height\" format given bounding box subsetted from a  \n        row from, e.g. a csv.  The subset of columns in the input row should be defined in the config, \n        and should contain a bounding box in \"top left, width/height\" format.\n\n        Parameters\n        ----------\n        row: Sequence\n            a row, e.g. from a csv.  The bounding box should be in some columns of this row\n            as defined in the configuration\n\n        Returns\n        -------\n        bbox: list[int,int,int,int]\n            the bounding box as [top_left_x, top_left_y, width, height]\n        '''\n        return [int(float(row[i])) for i in self.bbox_cols]\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.IterableBBoxParser.get_bbox","title":"<code>get_bbox(row)</code>","text":"<p>this method gets overwritten in init if the config has a bbox option</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Sequence</code> <p>a row, e.g. from a csv.  The bounding box should be in some columns of this row as defined in the configuration</p> required <p>Returns:</p> Name Type Description <code>bbox</code> <code>list[int, int, int, int]</code> <p>the bounding box as [top_left_x, top_left_y, width, height]</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>def get_bbox(self, row: Sequence) -&gt; list[int, int, int, int] | None:\n    '''\n    this method gets overwritten in __init__ if the config has a bbox option\n\n    Parameters\n    ----------\n    row: Sequence\n        a row, e.g. from a csv.  The bounding box should be in some columns of this row\n        as defined in the configuration\n\n    Returns\n    -------\n    bbox: list[int,int,int,int]\n        the bounding box as [top_left_x, top_left_y, width, height]\n    '''\n    return None\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.IterableKeypointParser","title":"<code>IterableKeypointParser</code>","text":"<p>               Bases: <code>object</code></p> <p>This class is to help parse keypoints from \"row\" data.  Sometimes these data are in different formats, so this class is intended to assist in dealing with these nuances</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Iterable2COCOConfig</code> <p>this configuration should define how (and if) bounding boxes are present in each row</p> required Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>class IterableKeypointParser(object):\n    '''\n    This class is to help parse keypoints from \"row\" data.  Sometimes these data\n    are in different formats, so this class is intended to assist in dealing with these nuances\n\n    Parameters\n    ----------\n    config: Iterable2COCOConfig\n        this configuration should define how (and if) bounding boxes are present in each row\n    '''\n    FULLY_VISIBLE_COCO_KEYPOINT = 2\n\n    def __init__(self, config: Iterable2COCOConfig):\n        self.config = config\n\n    def keypoint_config(self) -&gt; tuple[list[str], list[list[int]]]:\n        '''\n        get the keypoint layout from the configuration file.  the coco keypoint layout is\n        ['kpname1', 'kpname2', ...]\n        and also a skeleton\n        [edge1, edge2, ...]\n        where edges are two-tuples of 1-indexed indexes of keypoints.  For example, if keypoints are:\n        ['hip', 'knee', 'ankle'],\n        the skeleton would be:\n        [[1,2],[2,3]] because the hip has an edge with the knee, and the knee has an edge to the ankle.\n\n        both of these items should be defined in the configuration\n\n        TODO: we only support ONE keypoint structure per configuration right now....\n        if you have multiple possible keypoint structures\n        e.g. hands and also human poses, then we need to rework this to be more general\n\n        Returns\n        -------\n        keypoints: list[str]\n            the list of keypoint names\n        skeleton: list[list[int]]\n            the skeleton corresponding to the keypoint names\n        '''\n        return (\n            [\n                keypoint.name for keypoint in self.config.keypoints\n            ],\n            self.config.keypoint_skeleton\n        )\n\n    def get_keypoints(self, row: Sequence) -&gt; list[int]:\n        '''\n        get keypoints from a \"flat\" row using expected indices in the row of keypoints \n        defined in self.config\n\n        Parameters\n        ----------\n        row: Sequence\n            a row, e.g. from a csv.  The keypoints should be in some columns of this row\n            as defined in the configuration\n\n        Returns\n        -------\n        keypoints: list[int]\n            keypoint locations in form [x1,y1,v1,x2,y2,v2,....] where x,y are the location and v is the\n            \"visibility\" according to the COCO docs\n        '''\n        if 'keypoints' not in self.config:\n            return None\n        return sum(\n            [\n                [\n                    int(float(row[keypoint.x])),\n                    int(float(row[int(keypoint.y)])),\n                    IterableKeypointParser.FULLY_VISIBLE_COCO_KEYPOINT if 'visibility' not in keypoint else int(float(row[keypoint.visibility]))\n                ]\n                for keypoint in self.config.keypoints\n            ],\n            []\n        )\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.IterableKeypointParser.get_keypoints","title":"<code>get_keypoints(row)</code>","text":"<p>get keypoints from a \"flat\" row using expected indices in the row of keypoints  defined in self.config</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Sequence</code> <p>a row, e.g. from a csv.  The keypoints should be in some columns of this row as defined in the configuration</p> required <p>Returns:</p> Name Type Description <code>keypoints</code> <code>list[int]</code> <p>keypoint locations in form [x1,y1,v1,x2,y2,v2,....] where x,y are the location and v is the \"visibility\" according to the COCO docs</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>def get_keypoints(self, row: Sequence) -&gt; list[int]:\n    '''\n    get keypoints from a \"flat\" row using expected indices in the row of keypoints \n    defined in self.config\n\n    Parameters\n    ----------\n    row: Sequence\n        a row, e.g. from a csv.  The keypoints should be in some columns of this row\n        as defined in the configuration\n\n    Returns\n    -------\n    keypoints: list[int]\n        keypoint locations in form [x1,y1,v1,x2,y2,v2,....] where x,y are the location and v is the\n        \"visibility\" according to the COCO docs\n    '''\n    if 'keypoints' not in self.config:\n        return None\n    return sum(\n        [\n            [\n                int(float(row[keypoint.x])),\n                int(float(row[int(keypoint.y)])),\n                IterableKeypointParser.FULLY_VISIBLE_COCO_KEYPOINT if 'visibility' not in keypoint else int(float(row[keypoint.visibility]))\n            ]\n            for keypoint in self.config.keypoints\n        ],\n        []\n    )\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.IterableKeypointParser.keypoint_config","title":"<code>keypoint_config()</code>","text":"<p>get the keypoint layout from the configuration file.  the coco keypoint layout is ['kpname1', 'kpname2', ...] and also a skeleton [edge1, edge2, ...] where edges are two-tuples of 1-indexed indexes of keypoints.  For example, if keypoints are: ['hip', 'knee', 'ankle'], the skeleton would be: [[1,2],[2,3]] because the hip has an edge with the knee, and the knee has an edge to the ankle.</p> <p>both of these items should be defined in the configuration</p> <p>TODO: we only support ONE keypoint structure per configuration right now.... if you have multiple possible keypoint structures e.g. hands and also human poses, then we need to rework this to be more general</p> <p>Returns:</p> Name Type Description <code>keypoints</code> <code>list[str]</code> <p>the list of keypoint names</p> <code>skeleton</code> <code>list[list[int]]</code> <p>the skeleton corresponding to the keypoint names</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>def keypoint_config(self) -&gt; tuple[list[str], list[list[int]]]:\n    '''\n    get the keypoint layout from the configuration file.  the coco keypoint layout is\n    ['kpname1', 'kpname2', ...]\n    and also a skeleton\n    [edge1, edge2, ...]\n    where edges are two-tuples of 1-indexed indexes of keypoints.  For example, if keypoints are:\n    ['hip', 'knee', 'ankle'],\n    the skeleton would be:\n    [[1,2],[2,3]] because the hip has an edge with the knee, and the knee has an edge to the ankle.\n\n    both of these items should be defined in the configuration\n\n    TODO: we only support ONE keypoint structure per configuration right now....\n    if you have multiple possible keypoint structures\n    e.g. hands and also human poses, then we need to rework this to be more general\n\n    Returns\n    -------\n    keypoints: list[str]\n        the list of keypoint names\n    skeleton: list[list[int]]\n        the skeleton corresponding to the keypoint names\n    '''\n    return (\n        [\n            keypoint.name for keypoint in self.config.keypoints\n        ],\n        self.config.keypoint_skeleton\n    )\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.bbox_tlbr2xywh","title":"<code>bbox_tlbr2xywh(bbox)</code>","text":"<p>Convert a bounding box in \"top left, bottom right\" format  to a bounding box in \"top left, width height\" format</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple[int, int, int, int]</code> <p>a four-tuple of [top_left_x, top_left_y, bottom_right_x, bottom_right_y]</p> required <p>Returns:</p> Name Type Description <code>bbox</code> <code>tuple[int, int, int, int]</code> <p>a four-tuple of [top_left_x, top_left_y, width, height]</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>def bbox_tlbr2xywh(bbox: tuple[int, int, int, int]) -&gt; tuple[int, int, int, int]:\n    '''\n    Convert a bounding box in \"top left, bottom right\" format \n    to a bounding box in \"top left, width height\" format\n\n    Parameters\n    ----------\n    bbox: tuple[int,int,int,int]\n        a four-tuple of [top_left_x, top_left_y, bottom_right_x, bottom_right_y]\n\n    Returns\n    -------\n    bbox: tuple[int,int,int,int]    \n        a four-tuple of [top_left_x, top_left_y, width, height]\n    '''\n    return (bbox[0], bbox[1], bbox[2] - bbox[0], bbox[3] - bbox[1])\n</code></pre>"},{"location":"api/csv2coco/#pycocowriter.csv2coco.parse_csv","title":"<code>parse_csv(config, filename)</code>","text":"<p>Helper method to open a csv file and pass it row-by-row into the COCO builder</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>a dictionary conforming to the Iterable2COCOConfig.SCHEMA</p> required <code>filename</code> <code>str</code> <p>a csv file to be read and converted to COCO</p> required <p>Returns:</p> Name Type Description <code>images</code> <code>list[COCOImage]</code> <p>a list of COCOImage reflecting the images from the csv file</p> <code>annotations</code> <code>list[COCOAnnotation]</code> <p>a list of COCOAnnotation reflecting the annotations from the csv file</p> <code>categories</code> <code>list[COCOCategory]</code> <p>a list of COCOCategory reflecting the categories of the annotations</p> Source code in <code>pycocowriter/csv2coco.py</code> <pre><code>def parse_csv(config: dict, filename: str) -&gt; tuple[\n    list[coco.COCOImage], list[coco.COCOAnnotation], list[coco.COCOCategory]]:\n    \"\"\"Helper method to open a csv file and pass it row-by-row into the COCO builder\n\n    Parameters\n    ----------\n    config : dict\n        a dictionary conforming to the Iterable2COCOConfig.SCHEMA\n    filename : str\n        a csv file to be read and converted to COCO\n\n    Returns\n    -------\n    images : list[COCOImage]\n        a list of COCOImage reflecting the images from the csv file\n    annotations : list[COCOAnnotation]\n        a list of COCOAnnotation reflecting the annotations from the csv file\n    categories : list[COCOCategory]\n        a list of COCOCategory reflecting the categories of the annotations\n    \"\"\"\n    csv2coco = Iterable2COCO(Iterable2COCOConfig(config))\n    with open(filename) as f:\n        reader = csv.reader(f)\n        images, annotations, categories = csv2coco.parse(reader)\n    return images, annotations, categories\n</code></pre>"},{"location":"api/utils/","title":"utilities module","text":""},{"location":"api/utils/#pycocowriter.utils.AttrDict","title":"<code>AttrDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>This class allows javascript-like attribute access for dictionaries. Pass in a nested dictionary and recursively access members as attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; attr_dict = AttrDict({'foo': [{'bar': [1,2]}]})\n&gt;&gt;&gt; attr_dict.foo[0].bar[1] == 2\nTrue\n</code></pre> Source code in <code>pycocowriter/utils.py</code> <pre><code>class AttrDict(dict):\n    '''\n    This class allows javascript-like attribute access for dictionaries.\n    Pass in a nested dictionary and recursively access members as attributes.\n\n    Examples\n    --------\n    &gt;&gt;&gt; attr_dict = AttrDict({'foo': [{'bar': [1,2]}]})\n    &gt;&gt;&gt; attr_dict.foo[0].bar[1] == 2\n    True\n    '''\n    def __init__(self, some_dict:dict):\n        super().__init__(some_dict)\n        self.__dict__ = {\n            k: _to_attrdict(v) for k,v in some_dict.items()\n        }\n</code></pre>"},{"location":"api/utils/#pycocowriter.utils.NPEncoder","title":"<code>NPEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>json encoder class used to convert numpy types into plain python types during json.dumps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; json.dumps({'array': np.array([1,2,3])}, cls=NPEncoder)\n'{\"array\": [1, 2, 3]}'\n</code></pre> Source code in <code>pycocowriter/utils.py</code> <pre><code>class NPEncoder(json.JSONEncoder):\n    '''\n    json encoder class used to convert numpy types into plain python types during json.dumps.\n\n    Examples\n    --------\n    &gt;&gt;&gt; json.dumps({'array': np.array([1,2,3])}, cls=NPEncoder)\n    '{\"array\": [1, 2, 3]}'\n\n    '''\n    def default(self, obj):\n        if isinstance(obj, np.integer):\n            return int(obj)\n        if isinstance(obj, np.floating):\n            return float(obj)\n        if isinstance(obj, np.ndarray):\n            return obj.tolist()\n        return super(NPEncoder, self).default(obj)\n</code></pre>"},{"location":"api/utils/#pycocowriter.utils.skiprows","title":"<code>skiprows(iterable, n)</code>","text":"<p>skips the first n rows of iterable.  returns iterable as a convenience</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>the iterable to skip rows of</p> required <code>n</code> <code>int</code> <p>the number of rows to skip</p> required <p>Returns:</p> Name Type Description <code>iterable</code> <code>Iterable</code> <p>the original iterable, but now with n rows having been skipped</p> Source code in <code>pycocowriter/utils.py</code> <pre><code>def skiprows(iterable: Iterable, n: int) -&gt; Iterable:\n    '''\n    skips the first n rows of iterable.  returns iterable as a convenience\n\n    Parameters\n    ----------\n    iterable: Iterable\n        the iterable to skip rows of\n    n: int\n        the number of rows to skip\n\n    Returns\n    -------\n    iterable: Iterable\n        the original iterable, but now with n rows having been skipped\n    '''\n    for i in range(n):\n        next(iterable)\n    return iterable\n</code></pre>"}]}